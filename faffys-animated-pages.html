<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../../bower_components/app-route/app-location.html">


<!-- // move to index or another html page -->
<script src="../web-animations-js/web-animations.min.js"></script>


<dom-module id="faffys-animated-pages">
  <template>
    <style>
       :host {
        display: block;
      }

       :host> ::slotted(*) {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
      }

       :host> ::slotted(:not(.page):not(.animating)) {
        display: none !important;
      }

       :host> ::slotted(.animating) {
        pointer-events: none;
      }
    </style>
    <app-location route="{{route}}"></app-location>
    <slot id="pages"></slot>
  </template>

  <script>
    /**
    * `faffys-animated-pages`
    * Page Transitions with Web Animations API
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class WaapiPages extends Polymer.Element {
      static get is() { return 'faffys-animated-pages'; }
      static get properties() {
        return {
          /**
          * The animation request
          */
          animation: {
            type: Object,
            observer: '_load',
            reflectToAttribute: true,
            notify: true,
          },
          /**
          * True if the animate to page is loading
          */
          loading: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            notify: true
          },
          /**
          * True if the page is animating
          */
          animating: {
            type: Boolean,
            value: false
          },
          /**
          * Path is the page path
          * @type {String}
          */
          path: {
            type: String,
            value: 'src/pages/page-',
          },
          route: {
            type: Object,
            observer: '_page'
          },
          /**
          * The route
          * @type {String}
          */
          /**
          * an array of the page history to a length of 2 
          * @type {String}
          */
          pageHistory:{
            type: Array,
            value: []
          }

        };
      }

      _load() {
        const loadPath = `${this.path}${this.animation.to}.html`
        this.loading = true;
        Polymer.importHref(loadPath, this._loadComplete.bind(this), this._loadFailed.bind(this), false);
      }

      _animateBack(pageHistory){
          this.pageHistory.push(this.route.path);
          if(this.pageHistory.length > 2){
            this.pageHistory.shift();
          }

          let animateFrom = this.$.pages.assignedNodes().find(e => e.id === pageHistory[0].split('/').join(""));
          let animateTo = this.$.pages.assignedNodes().find(e => e.id === this.route.path.split('/').join(""));

          if(animateFrom.id != animateTo.id){
            console.log('Animate me');
            console.log('From: '+ animateFrom.id);
            console.log('To: ' + animateTo.id);
          } 
      }

      _loadComplete(e) {
        this.loading = false;
        this.animating = true;
        let animateFrom = this.$.pages.assignedNodes().find(e => e.id === this.animation.from);
        let animateTo = this.$.pages.assignedNodes().find(e => e.id === this.animation.to);

        // add animating class to outgoing and incoming pages.
        animateFrom.classList && animateFrom.classList.add('animating');
        animateTo.classList && animateTo.classList.add('animating');


        // notify all pages of running exit animation
        this.animation.exitPlaying = true;
        this.notifyPath('animation.exitPlaying');

        // do exit animation of outgoing page    
        let exitAnimation = animateFrom.animate
          (
          this.animation.descriptionArray,
          this.animation.descriptionObject
          );
        exitAnimation.play();

        // notify all pages of running entry animation
        this.animation.entryPlaying = true;
        this.notifyPath('animation.entryPlaying');

        // do entry animation of incoming page
        let entryAnimation = animateTo.animate
          (
          animateTo.entryAnimation.descriptionArray,
          animateTo.entryAnimation.descriptionObject
          );
        entryAnimation.play();

        exitAnimation.onfinish = () => {
          // notify all pages of finished exit animation
          this.animation.exitPlaying = false;
          this.notifyPath('animation.exitPlaying');

          // remove animating class from the animateFrom page
          animateFrom.classList && animateFrom.classList.remove('animating');
        }

        entryAnimation.onfinish = () => {
          // notify all pages of finished entry animation
          this.animation.entryPlaying = false;
          this.notifyPath('animation.entryPlaying');

          // remove animating class animateto page
          animateTo.classList && animateTo.classList.remove('animating');

        //change route
        this.set('route.path', this.animation.to + '/');
        this.animating = false;
        };

      }
      _loadFailed(err) {
        console.log(err)
      }

      _page() {
        if(this.animating == false){
          this._animateBack(this.pageHistory);
        } else {
          this.pageHistory.push(this.route.path);
          if(this.pageHistory.length > 2){
            this.pageHistory.shift();
          }
        }
        // you just landed or hit refresh
        if((this.pageHistory[0] == this.pageHistory[1]) || this.pageHistory.length < 1){
          console.log('You just landed or refreshed');
        }

        const pages = Polymer.dom(this.$.pages).getDistributedNodes();
        for (let page, i = 0; page = pages[i]; i++) {
          if (this.page == page.id) {
            page.classList && page.classList.add('page');
          } else {
            page.classList && page.classList.remove('page');
            page.classList && page.classList.remove('animating');
          }
        }
      }
    } window.customElements.define(WaapiPages.is, WaapiPages);
  </script>
</dom-module>